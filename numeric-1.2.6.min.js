const EA = 200000;

canvas.addEventListener('click', (e) => {
    const pos = { x: e.offsetX, y: e.offsetY };

    if (mode === 'node') {
        nodes.push({ x: pos.x, y: pos.y, support: null, load: 0 });
        saveHistory();
        draw();
    } else if (mode === 'member') {
        const n = getNodeAt(pos);
        if (n) {
            if (!selectedNode) {
                selectedNode = n;
            } else if (selectedNode !== n) {
                members.push({ start: selectedNode, end: n, force: 0 });
                selectedNode = null;
                saveHistory();
                solve();
                draw();
            }
        }
    }
});

canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    const pos = { x: e.offsetX, y: e.offsetY };
    const n = getNodeAt(pos);
    if (n) {
        const choice = prompt('Type: support / roller / load');
        if (choice === 'support') n.support = 'hinge';
        else if (choice === 'roller') n.support = 'roller';
        else if (choice === 'load') {
            const f = parseFloat(prompt('Load value (positive down):'));
            if (!isNaN(f)) n.load = f;
        }
        saveHistory();
        solve();
        draw();
    }
});

function startNode() { mode = 'node'; }
function startMember() { mode = 'member'; }
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    for (let m of members) {
        ctx.beginPath();
        ctx.moveTo(m.start.x, m.start.y);
        ctx.lineTo(m.end.x, m.end.y);
        ctx.strokeStyle = m.force > 0 ? 'green' : 'red';
        ctx.lineWidth = 3;
        ctx.stroke();

        const midX = (m.start.x + m.end.x) / 2;
        const midY = (m.start.y + m.end.y) / 2;
        ctx.fillStyle = 'black';
        ctx.fillText(m.force.toFixed(1) + 'N', midX + 5, midY - 5);
    }
    for (let n of nodes) {
        ctx.beginPath();
        ctx.arc(n.x, n.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = 'blue';
        ctx.fill();
        ctx.stroke();

        if (n.support) {
            ctx.fillStyle = 'black';
            ctx.fillText(n.support, n.x + 8, n.y + 4);
        }
        if (n.load !== 0) {
            ctx.fillStyle = 'red';
            ctx.fillText(n.load + 'N', n.x + 8, n.y + 18);
        }
    }
}

function drawGrid() {
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 0.5;
    for (let x = 0; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}
function solve() {
    if (nodes.length < 2 || members.length < 1) return;

    const dof = nodes.length * 2;
    let A = Array.from({ length: dof }, () => Array(dof).fill(0));
    let b = Array(dof).fill(0);

    for (let m of members) {
        const idxA = nodes.indexOf(m.start);
        const idxB = nodes.indexOf(m.end);

        const dx = m.end.x - m.start.x;
        const dy = m.end.y - m.start.y;
        const l = Math.hypot(dx, dy);
        const c = dx / l;
        const s = dy / l;
        
        const k_local = (EA / l);

        const k = [
            [c * c, c * s, -c * c, -c * s],
            [c * s, s * s, -c * s, -s * s],
            [-c * c, -c * s, c * c, c * s],
            [-c * s, -s * s, c * s, s * s]
        ];

        const map = [
            2 * idxA, 2 * idxA + 1,
            2 * idxB, 2 * idxB + 1
        ];

        for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
                A[map[i]][map[j]] += k_local * k[i][j];
            }
        }
    }

    nodes.forEach((n, idx) => {
        b[2 * idx] = 0;
        b[2 * idx + 1] = -n.load; 
    });

    nodes.forEach((n, idx) => {
        if (n.support === 'hinge') {
            A[2 * idx] = Array(dof).fill(0);
            A[2 * idx][2 * idx] = 1;
            b[2 * idx] = 0;

            A[2 * idx + 1] = Array(dof).fill(0);
            A[2 * idx + 1][2 * idx + 1] = 1;
            b[2 * idx + 1] = 0;
        }
        else if (n.support === 'roller') {
            A[2 * idx + 1] = Array(dof).fill(0);
            A[2 * idx + 1][2 * idx + 1] = 1;
            b[2 * idx + 1] = 0;
        }
    });

    try {
        const disp = numeric.solve(A, b);

        members.forEach(m => {
            const idxA = nodes.indexOf(m.start);
            const idxB = nodes.indexOf(m.end);

            const dx = m.end.x - m.start.x;
            const dy = m.end.y - m.start.y;
            const l = Math.hypot(dx, dy);
            const c = dx / l;
            const s = dy / l;

            const du = (disp[2 * idxB] - disp[2 * idxA]) * c + (disp[2 * idxB + 1] - disp[2 * idxA + 1]) * s;
            m.force = (EA / l) * du;
        });

    } catch (err) {
        console.error('Failed to solve', err);
    }
}
function saveHistory() {
    history.push(JSON.stringify({ nodes, members }));
    redoStack = [];
}

function undo() {
    if (history.length > 1) {
        redoStack.push(history.pop());
        const last = JSON.parse(history[history.length - 1]);
        nodes = JSON.parse(JSON.stringify(last.nodes));
        members = JSON.parse(JSON.stringify(last.members));
        draw();
    }
}

function redo() {
    if (redoStack.length) {
        const next = redoStack.pop();
        history.push(next);
        const last = JSON.parse(next);
        nodes = JSON.parse(JSON.stringify(last.nodes));
        members = JSON.parse(JSON.stringify(last.members));
        draw();
    }
}

function saveTruss() {
    const data = { nodes, members };
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'truss.json';
    a.click();
}

function loadTruss() {
    fileInput.click();
}

document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = function() {
        const data = JSON.parse(this.result);
        nodes = data.nodes;
        members = data.members;
        draw();
    };
    reader.readAsText(file);
});

function exportImage() {
    const a = document.createElement('a');
    a.download = 'truss.png';
    a.href = canvas.toDataURL();
    a.click();
}

function getNodeAt(pos) {
    return nodes.find(n => Math.hypot(n.x - pos.x, n.y - pos.y) < 10);
}function saveHistory() {
    history.push(JSON.stringify({ nodes, members }));
    redoStack = [];
}

function undo() {
    if (history.length > 1) {
        redoStack.push(history.pop());
        const last = JSON.parse(history[history.length - 1]);
        nodes = JSON.parse(JSON.stringify(last.nodes));
        members = JSON.parse(JSON.stringify(last.members));
        draw();
    }
}

function redo() {
    if (redoStack.length) {
        const next = redoStack.pop();
        history.push(next);
        const last = JSON.parse(next);
        nodes = JSON.parse(JSON.stringify(last.nodes));
        members = JSON.parse(JSON.stringify(last.members));
        draw();
    }
}

function saveTruss() {
    const data = { nodes, members };
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'truss.json';
    a.click();
}

function loadTruss() {
    fileInput.click();
}

document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = function() {
        const data = JSON.parse(this.result);
        nodes = data.nodes;
        members = data.members;
        draw();
    };
    reader.readAsText(file);
});

function exportImage() {
    const a = document.createElement('a');
    a.download = 'truss.png';
    a.href = canvas.toDataURL();
    a.click();
}

function getNodeAt(pos) {
    return nodes.find(n => Math.hypot(n.x - pos.x, n.y - pos.y) < 10);
}